```c
## Memoria compartida
S = sem(1)
R = sem(1)
x = 0
```

```c
void foo( ) {
    do {
        semWait(S);
        semWait(R);
        x++;
        semSignal(S);
        semSignal(R);
    } while (1);
}
```

```c
void bar( ) {
    do {
        semWait(R);
        semWait(S);
        x--;
        semSignal(S);
        semSignal(R);
    } while (1);
}
```

## a)
- Foo ejecuta `semWait(S)`. S pasa a valer 0, la proxima instruccion es semWait(R) pero Foo es desalojada.
- Bar ejecuta `semWait(R)`. R pasa a valer 0,.
- Bar ejecuta `semWait(S)`. S vale 0, Bar queda bloqueada.
- Foo ejecuta `semWait(R)`. R vale 0, Foo queda bloqueada.
- DEADLOCK. Ninguna puede avanzar.

## b)
Si siempre que le toque ejecutar a bar, justo ambos semaforos estan bloqueado (pues foo hizo ambos waits pero aun ningun signal), entonces bar nunca podra avanzar y tendr√° inanicion.  
Notar que esto supone que el signal() en vez de despertar a algun proceso de los que se encuentren esperando en la cola del semaforo, solo aumenta en 1 el valor.

