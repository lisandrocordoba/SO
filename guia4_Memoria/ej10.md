
### Estructura de disco
- Paginas de 200 bytes
- De 0 a 199 el programa

### Estructura de memoria
Tenemos 3 frames:
- Frame 0: El programa
- Frame 1 y 2: vacios.

### Analicemos A:
```
int A[][] = new int[100][100];
```
- A empieza en 200 y su tama침o es `100 * 100 * sizeof(int) = 40000 bytes`
- De 200 a 40200 son las paginas de A

Si bien es un array, en memoria se guarda como un array lineal, es decir:

`[A[0][0], A[0][1], A[0][2], ..., A[0][99], A[1][0], A[1][1], ..., A[99][99]]`  

Como los int ocupan 4 bytes, cada fila de A ocupa 400 bytes (100 * 4). En 1 pagina entran 200 bytes, por lo que cada fila de A ocupa 2 paginas.

Notemos que:
- Si traemos la pagina que contiene `A[0][0]`, tambien traemos hasta `A[0][49]` (200 bytes).
- Si traemos la pagina que contiene `A[0][50]`, tambien traemos hasta `A[0][99]` (200 bytes).
- Jamas traeremos en una misma pagina algo de distinta fila.

### a)
Si iteramos por columnas, cada acceso a `A[i][j]` traer치 una pagina nueva, ya que `A[i][j]` y `A[i+1][j]` estan en distintas paginas.

#### Cantidad de page faults
Habiendo 100 filas y 100 columnas y teniendo un page fault por cada acceso, tenemos un total de **10000 page faults**.

### b)
Por lo analizado, es facil ver que ser치 mucho mas eficiente recorrer A por filas, ya que al traer una pagina, estamos trayendo 50 elementos de la misma fila, y los siguientes 50 elementos a acceder ya estan en memoria.

#### Cantidad de page faults
Como el frame 0 esta ocupado por el programa y LRU no lo va a desalojar (pues constantemente se fetchea instrucciones), tenemos 2 frames para A.  
El acceso a `A[0][0]` ser치 un page fault y recien tendremos otro en `A[0][50]`. Esto se repite para cada fila.  
Habiendo 100 filas y 2 page faults por fila, tenemos un total de **200 page faults**. 
